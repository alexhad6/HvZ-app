Team: HvZ App


Members: Kyra Clark, Santiago Rodriguez, Alex Hadley, Matthew Waddell
Project 3B — Component Specifications


Plan: https://github.com/alexhad6/HvZ-app/blob/master/Administrative/Phase%203/spec_3b_KC.txt
        Primary author: Kyra Clark


Component Specifications: Database


COMPONENT DESCRIPTION AND ROLE IN OVERALL SYSTEM

The database will be responsible for holding all of the relevant player data for each game. This 
includes player or moderator status, name, human or zombie status, number of brains (zombie 
currency), legendary status, school, class year, email, and dorm. Each player will have a unique 
Player ID so that they can be referenced when needed from the database. The database also stores 
information for each game such as the number of players and which players are playing. It can 
store relationships among players such as Player A turned Player B into a zombie. Select 
information from the database will be accessible by other parts of the architecture. In general, 
the database serves as the place where player information is stored for each game in order for 
gameplay interactions to occur successfully between players and the application. 


ARCHITECTURE CONNECTIONS AND INTERFACES

The database component serves to provide access to information to enable gameplay. This information 
will appear on the user interface of the application, as well as the app itself. As much of the 
player information is critical for gameplay, the database will be working directly with the 
application to supply information. Additionally, the database will work closely with Authentication 
because Authentication will determine who is allowed to call and access the information and 
functions of the database. Authentication will work with logging in a specific user, whose 
information and user ID will be provided by the database. 
Below are more thorough descriptions of the interfaces and connections between the database, 
Authentication, and application:

Application ↔︎ Database
The application sends a request to read from or write to the database (e.g. to view the number of 
humans or zombies or to update mission information, etc.), along with the user’s ID, a signed JSON 
Web Token. The database can then verify the ID token to get the identity of the user requesting 
data. We will have permissions set up so that only certain users can perform particular operations. 
For example, only zombies can transfer brains to other zombies. The database will then send back 
the requested data or confirmation that data was changed. The application will also reorganize the 
database when a new game is being created (the database will then handle storing new game 
information in a different place than the old one). This means that authentication in connection 
with the application will determine who can call which read/write functions to the database, which 
is what will be built in this component. 

Registration/Authentication ↔︎ Database
After a player signs in to the registration website and is authenticated, they will fill in 
information such as class year and school. The registration website will then register the user 
by adding this information to the database and generating a feed code. The website will also send 
a confirmation email to the user with their generated feed code and additional game information. 
The website will check for confirmation that registration was successful, and it will sign the 
current user out so that someone else can register (when mods are registering people at club fairs 
or in dining halls). The Player ID is generated by the Sign-in functions, which is a random string 
of letters and numbers that will be passed into many of these database functions to retrieve other 
player information. Furthermore, other information like name and email will be handled in sign in 
through their Google account. 

File Storage ↔︎ Database
The database will also store necessary information needed to store, download, and display the 
objects in file storage. This will entail having a section of the Database used to store paths as 
strings to find each object in the file storage component. Each file will have a unique Mission Number so 
that they can be referenced when needed from the database.



FUNCTIONS / METHODS

* Read Functionality
   * The database component will include several methods in order to access various information about 
     the players to enable gameplay. For each player, the database stores their Player ID, player or 
     moderator status, human or zombie status, number of brains (zombie currency), legendary status, 
     school, class year, and dorm. This information will be used both from gameplay in terms of keeping 
     track of brains and other relevant statistical information. Below is listed the various kinds of read 
     functions there will be:
   * Get list of current users from database
      * This will be used for displaying information about who is still alive on the homepage of the 
	application. This function will likely be used for various methods involving searching through or 
	displaying the full list of players.
      * Called By: Application 
      * Input: NA
      * Output: ArrayList of Player names stored as Strings
   * Get number of humans and zombies from database
      * This will be used similarly to the function which will get a list of all current users and 
	players. This will be used to display the number of each kind of player. It will be used to display 
	various information about live-game statistics on the front page of the application. 
      * Called By: Application
      * Input: NA
      * Output: Two Integers as a Tuple of the number of humans and zombies
   * Get specific player information
      * This will involve various methods for each kind of info stored (name, email, school, 
	human/zombie status, etc.) which will simply return that stored information for a single player. 
	This will look like many various functions appearing similar to, “getSchool([Player]).” All stored 
	information of players should be retrievable for statistics and data
      * Called By: Application (to display stats), File Storage (to correctly display information as 
	files for each user), Authentication (to determine who can use or call other functions and methods)
      * Input: Player ID
      * Output: their specific information as a String or Integer (for zombie currency) 


* Write Functionality
   * As the game is played, often the moderators need to adjust player statistics from the database. This 
     includes moderators updating legendary status for zombies, and resurrecting human players (changing their 
     status from zombie back to human). Below is listed the various kinds of write functions there will be:
   * Write info
      * This function writes in all the ascribed sign in information that is given when the person registers. 
	This includes the user feed code and a randomized Player ID. 
      * Called By: Sign in, Registration
      * Input: all the information needed as an Array of Strings and Integers (name, email, school, 
	human/zombie status, etc.)
      * Output: NA (a new user of Player ID is created with their associated information)
   * Change ‘Legendary’ Status
      * Called By: Application, Moderators only (Authentication)
      * Input: Player ID, new status as String
      * Output: NA (that Player ID’s status was changed to the new given string)
   * Resurrect Zombie
      * Called By: Application, Moderators only (Authentication)
      * Input: Player ID
      * Output: NA (that Player ID’s player status was changed to human)
      * Note: Be sure to check that the Player ID is already a zombie in case of user error (use 
	aforementioned getPlayerStatus())
   * Change into Zombie (“Eat Human”)
      * Called By: Application, during eating process by Zombie (Authentication)
      * Input: Player ID A (Zombie), Player ID B (Human)
      * Output: NA (Player B’s player status was changed to zombie, Player A’s brain currency increased by 1)
      * Note: Be sure to check that the Player A is a human in case of user error (use aforementioned 
	getPlayertStatus())
   * Increment Brain Currency
      * Called By: Application, during Eat Human function
      * Input: Player ID (Zombie)
      * Output: NA (Player ID’s brain currency increased by 1)
   * Add Moderator Privileges
      * Called By: Application, by Moderators (Authentication)
      * Input: Player ID
      * Output: NA (that Player ID’s Mod status was changed to Moderator)
   * Remove Moderator Privileges
      * Called By: Application, by Moderators (Authentication)
      * Input: Player ID
      * Output: NA (that Player ID’s Mod status was changed to Player)


* Zombie Brain Transfer
   * In the game, it is possible for zombie players to transfer their brain currency to another zombie. This 
     entails changing the number of brains of Player A by x number of brains, and increasing the specified Player 
     B’s brains by x amount. 
      * Called By: Application, Zombie players only (Authentication)
      * Input: Player A’s ID (transferring), Player B’s ID (receiving), Integer number of brains
      * Output: NA (that Player B’s brains increase by the specified integer amount)
      * Note: Be sure to check that Player B ID is a zombie in case of user error (use aforementioned 
	getPlayerStatus()).


* Reset game-specific player data
   * When the week-long game ends, the database should be wiped clear for future games. This would entail 
     completely deleting all the player information. 
      * Called By: Application, Moderators only (Authentication)
      * Input: NA
      * Output: NA


* File Storage 
   * Write Path to a File
      * The Database will store the paths as strings of all the objects in file storage. This function will 
	write the file path and create a new object in the database.
      * Called By: File Storage
      * Input: File Path as a String, Mission Number
      * Output: NA (the file path will appear under a new entry in the database associated with the mission 
	number.)
   * Return a File Path
      * This function will search through all the paths to find that one associated with the correct mission 
	number, and return its associated file. 
      * Called By: File Storage
      * Input: Mission Number
      * Output: File Path as a String



FEASIBILITY

This database component is feasible for our project. We will be using the Cloud Firestore Database 
(https://firebase.google.com/docs/firestore). It is a document-based NoSQL database which allows us to store 
information in a simple way. Because our data needs are relatively simple, we don’t need to worry about complex 
database operations. The service is a pay as needed type, and with our limited needs it will be free for a 
long while. Furthermore, it has libraries to directly interface with ios, android, and web applications. This 
allows us to consider building a website in the future with very little changes to our architecture. As a 
Firebase product, it interfaces easily with other Firebase products, such as Cloud Storage, which is the 
implementation of the file storage system that we are considering. In summary, we plan to use an off-the-shelf 
product to implement our database, and we know that it will fit our needs and interface nicely with the other 
components of our architecture.

For this part of the project, implementing this specified component will be suitable. Although the coding demands 
are relatively simple, there are a fair number of them to account for. Furthermore, the complexity of this 
component will come in by communicating in a clear, and effective way with the other components who want access 
to this information. As the database accesses information to be used throughout most of the processes of the 
app, it is one of the more interconnected components of the project. Finally, we will also need to search through, 
delete, and update data in a time-efficient manner, which will allow users to easily access any information they 
need without impairing the system. 

These functions for the database are also suitable because they are definitely testable. By creating a small 
prototyped database, with known player information, we can easily and automatically test the functions to be sure 
they are reading, writing, and deleting the proper data. This will involve writing test cases that search through, 
access, and write data and comparing it to the expected output. Furthermore, later with a more complex prototype 
that has been incorporated alongside other components like Authentication, and the Applications, we will be able 
to input much more complex user data. This testing is important, not only because it will allow us to see if the 
components are communicating together effectively, but also because we will be able to test when the Database 
functions and successfully called or not by the Application, as specified by the Authentication.